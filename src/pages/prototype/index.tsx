'use client';

import { Heading, Stack, Text, Code } from '@chakra-ui/react';
import { Fragment } from 'react';

import { PatternInfo } from '../../components/pattern-info';

const PrototypePage = () => {
  return (
    <Fragment>
      <PatternInfo
        title="Prototype (Прототип)"
        description="Паттерн Prototype позволяет создавать новые объекты путём клонирования уже существующих (прототипов), вместо создания с нуля. 
        В отличие от других способов создания объектов, здесь акцент на том, что объект выступает «шаблоном» для новых объектов."
        advantages={[
          'Ускоряет создание сложных объектов',
          'Позволяет легко копировать существующие структуры',
          'Удобен при работе с шаблонами или повторяющимися элементами',
          'Можно создавать новые объекты с минимальными изменениями',
        ]}
        disadvantages={[
          'Сложность реализации глубокого копирования',
          'Может быть избыточным для простых структур',
          'Требует аккуратного проектирования API, чтобы избежать ошибок',
        ]}
        usage={[
          'Графические редакторы (копирование фигур, слоёв)',
          'Игры (клонирование персонажей, врагов, предметов)',
          'UI-компоненты (создание повторяющихся элементов)',
          'Конфигурации и шаблоны (клонирование и модификация настроек)',
          'Работа с документами, письмами и сообщениями по готовым шаблонам',
        ]}
      />

      <Heading size="lg" mt={12} mb={4}>
        Prototype и JavaScript
      </Heading>

      <Stack gap={3}>
        <Text>
          В JavaScript <b>всё построено на паттерне Prototype</b>. Каждая функция-конструктор имеет
          свойство <Code>prototype</Code>, которое используется как шаблон для всех создаваемых
          объектов. Любой объект хранит скрытую ссылку <Code>[[Prototype]]</Code>, указывающую на
          свой прототип.
        </Text>

        <Text>
          Это означает, что вместо классового наследования, как в классических ООП-языках, в JS
          работает <b>прототипное наследование</b>. Один объект может служить прототипом для
          другого, а свойства и методы ищутся по цепочке прототипов.
        </Text>

        <Text>Например:</Text>
        <Code p={2} whiteSpace="pre-wrap">
          {`const animal = { eats: true };
const dog = Object.create(animal);
dog.barks = true;

console.log(dog.eats); // true (унаследовано из animal)
console.log(dog.barks); // true (собственное свойство)`}
        </Code>

        <Text>
          Здесь <Code>dog</Code> был создан на основе <Code>animal</Code>. Такой механизм — это и
          есть практическая реализация паттерна Prototype в самом языке.
        </Text>
      </Stack>
    </Fragment>
  );
};

export default PrototypePage;
